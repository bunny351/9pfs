rsc uses a single function for all actual calls to the 9p server:
/usr/local/plan9/src/lib9pclient/fs.c:/^_fsrpc

might want to adapt that...

it's fusedispatch that calls a thread to handle the fuse message.
That runs in its own proc and reads from fusechan. fusereader also
runs in its own proc and gets FuseMsg from readfusemsg and sends
it on to fusechan.

It is readfusemsg (in fuse.c) that constructs the FuseMsg from what
it reads off the fusefd.

Man this gets complicated. There appears to be a lot of machinery
that converts nodeids (numbers associated with opened files?) to
actual paths. I shouldn't need to worry about that, I just need to
wade my way through all that.

fuse ops rsc has implemented.
struct {
	int op;
	void (*fn)(FuseMsg*);
} fuselist[] = {
	{ FUSE_LOOKUP,		fuselookup },
	{ FUSE_FORGET,		fuseforget },
	{ FUSE_GETATTR,		fusegetattr },
	{ FUSE_SETATTR,		fusesetattr },
	/*
	 * FUSE_SYMLINK, FUSE_MKNOD are unimplemented.
	 */
	{ FUSE_READLINK,	fusereadlink },
	{ FUSE_MKDIR,		fusemkdir },
	{ FUSE_UNLINK,		fuseunlink },
	{ FUSE_RMDIR,		fusermdir },
	{ FUSE_RENAME,		fuserename },
	/*
	 * FUSE_LINK is unimplemented.
	 */
	{ FUSE_OPEN,		fuseopen },
	{ FUSE_READ,		fuseread },
	{ FUSE_WRITE,		fusewrite },
	{ FUSE_STATFS,		fusestatfs },
	{ FUSE_RELEASE,		fuserelease },
	{ FUSE_FSYNC,		fusefsync },
	/*
	 * FUSE_SETXATTR, FUSE_GETXATTR, FUSE_LISTXATTR, and
	 * FUSE_REMOVEXATTR are unimplemented. 
	 * FUSE will stop sending these requests after getting
	 * an -ENOSYS reply (see dispatch below).
	 */
	{ FUSE_FLUSH,		fuseflush },
	/*
	 * FUSE_INIT is handled in initfuse and should not be seen again.
	 */
	{ FUSE_OPENDIR,		fuseopendir },
	{ FUSE_READDIR,		fusereaddir },
	{ FUSE_RELEASEDIR,	fusereleasedir },
	{ FUSE_FSYNCDIR,	fusefsyncdir },
	{ FUSE_ACCESS,		fuseaccess },
	{ FUSE_CREATE,		fusecreate },
};

So a tutorial says you start with init, getattr, and readdir.
Then you have a functioning informational file system that you
can't do anything to do.

Here is a transcript of a walk and read:
[0 frog:~]$ 9p -D -na pika.codigo.co read usr/glenda/lib/profile
<- Tversion tag 0 msize 8192 version '9P2000'
-> Rversion tag 65535 msize 8192 version '9P2000'
<- Tattach tag 0 fid 0 afid -1 uname ben aname 
-> Rattach tag 0 qid (0000000000000001 25 d)
<- Twalk tag 0 fid 0 newfid 1 nwname 4 0:usr 1:glenda 2:lib 3:profile 
-> Rwalk tag 0 nwqid 4 0:(000000000000000e 3 d) 1:(000000000000000f 4 d) 2:(000000000000c081 5 d) 3:(000000000000c083 2 ) 
<- Topen tag 0 fid 1 mode 0
-> Ropen tag 0 qid (000000000000c083 2 ) iounit 8168
<- Tread tag 0 fid 1 offset 0 count 4096
-> Rread tag 0 count 830 '62696e64 202d6120 24686f6d 652f6269 6e2f7263 202f6269 6e0a6269 6e64202d 61202468 6f6d652f 62696e2f 24637075 74797065 202f6269 6e0a6d6f 756e7420'
bind -a $home/bin/rc /bin
bind -a $home/bin/$cputype /bin
mount -qC /srv/boot /n/other other
bind -qc /n/other/usr/$user/tmp $home/tmp
bind -c $home/tmp /tmp
if(! syscall create /tmp/xxx 1 0666 >[2]/dev/null)
	ramfs	# in case we're running off a cd
font=/lib/font/bit/vga/unicode.font
switch($service){
case terminal
	if(! webcookies >[2]/dev/null)
		webcookies -f /tmp/webcookies
	webfs
	plumber
	echo -n accelerated > '#m/mousectl'
	echo -n 'res 3' > '#m/mousectl'
	prompt=('term% ' '	')
	fn term%{ $* }
	rio -i riostart
case cpu
	bind /mnt/term/dev/cons /dev/cons
	bind -q /mnt/term/dev/consctl /dev/consctl
	>[2] /dev/null {
		cp /dev/sysname /mnt/term/dev/label
		if(wsys=`{cat /mnt/term/env/wsys})
			wsys=/mnt/term^$wsys
	} 
	bind -a /mnt/term/dev /dev
	prompt=('cpu% ' '	')
	fn cpu%{ $* }
case con
	prompt=('cpu% ' '	')
}
<- Tread tag 0 fid 1 offset 830 count 4096
-> Rread tag 0 count 0 ''
<- Tclunk tag 0 fid 1
-> Rclunk tag 0


So how to handle errors...
set a global string? return the error?
return -1.

where are all my notes?

FUCK

how do we handle checking if the file changed? We just get a fresh
stat of that fid?







/*
uint32_t
fid(char *path)
{
	PFid	*f;

	f = lookup(path);
	if(f->fid == 0)
		f->fid = p9walk(path);
	return f->fid;
}

PFid*
lookup(char *path)
{
	FFid	*f;
	int	siz, h;

	h = hash(path);
	for(f = fidhash[h]; f != NULL; f = f->link){
		if(strcmp(f->path, path) == 0)
			break;
	}
	if(f == NULL){
		f = emalloc(sizeof(*f));
		siz = strlen(path) + 1;
		f->path = emalloc(siz);
		strecpy(f->path, f->path + siz, path);
		f->link = fidhash[h];
		fidhash[h] = f;
	}
	return f;
}

uint32_t
p9walk(char *path)
{
	struct Fcall f;
	char	*w[MAXWELEM], *p, *ap;
	size_t	siz;
	uint	nap;

	cleanname(path);
	siz = strlen(path) + 1;
	p = emalloc(len);
	strecpy(p, p + siz, path);
	f.nwname = getfields(p, f.wname, MAXWELEM, "/");
	f.type = Twalk;
	f.fid = ROOTFID;
	f.tag = newtag();
	f.newfid = newfid();
	nap = convS2M(f);
	ap = malloc(n);
	convS2M(f, ap, nap);
	write(p9fd, ap, nap);
	read9pmsg(p9fd, 
*/

1st time:
oldfid is 0
fid is rootfid
newfid is uniqfid

2nd time
0 is clunked
oldfid is uniqfid1
fid uniqfid1
newfid uniqfid2

3rd time
uniqfid1 is clunked
oldfid is uniqfid2
fid is uniqfid2
newfid is uniqfid3


just make _9pclunk not clunk the root fid.


rsc keeps this linked list of fids available.
When he gets rid of it one, it goes on a free
list.

the lookupfusefid method can potentially grab from
the end. Is that what happens when it is a new nodeid?

so pathlookup. We need to store a FFid in two hashes now. One
indexed by fid, the other by path.

For opendir, the only checking I need to do is check the type
against QTDIR.
this is FFid *fid; fid->qid.type&QTDIR

I really don't know what the fuck I am doing now...

I might want to use kqueue. I.e.:

do9p calls kqueue and somehow returns to the correct function...

it might be better just to write 9p into the kernel...

I should probably look at sshfs architecture.

This is what happens when I launch it  and then:

$ cd foo
$ ls

Call: Tversion on fid 929
Call: Tattach on fid 0
Root fid is: 0
about to enter main
Call: Tstat on fid 0
Call: Tstat on fid 0
Call: Tstat on fid 0
Call: Tstat on fid 0
Call: Tstat on fid 0
Call: Tstat on fid 0
Call: Tstat on fid 0
Call: Tstat on fid 0
Call: Tstat on fid 0
Call: Tstat on fid 0
Call: Tstat on fid 0
Call: Tstat on fid 0
Call: Twalk on fid 0
Call: Topen on fid 1244383886
Call: Tstat on fid 0
Call: Tstat on fid 0
Call: Tstat on fid 0
Call: Tstat on fid 0
Call: Tstat on fid 0
Call: Tstat on fid 0
trying to read the dir
Fid of the dir is: 1244383886
About to clunk
done with clunk
Call: Tread on fid 1244383886

so I don't know what that fid is.

look at
/usr/ports/pobj/sshfs-fuse-2.4/sshfs-fuse-2.4/sshfs.c:/^static int sshfs_open_common
for stuff on handling access modes and open modes.

So about making this faster.

You have one thread that processes reading. Your main thread does a write
and installs the tag in a hash table. The read function is just constantly
reading and looks up the tag in the hash table and returns it to the
correct thread.

Is this faster?

Gotchas

There are several common problems that plague programmers new to Fuse. This is a partial list:

Multithreading
By default, Fuse is multithreaded. That's handy for production filesystems, because it lets client (or file access) A proceed even if client B is hung up. But multithreading introduces the possibility of race conditions, and makes debugging harder. Always run with the -s switch to avoid this problem.
getattr
Fuse calls getattr like crazy. Implement it first, or nothing will work.
Truncate
Unless you're writing a read-only filesystem, you need to implement the truncate system call to make writes work correctly.
Working directory
When it starts, Fuse changes its working directory to "/". That will probably break any code that uses relative pathnames. To make matters worse, the chdir is suppressed when you run with the -f switch, so your code might appear to work fine under the debugger. To avoid the problem, either (a) use absolute pathnames, or (b) record your current working directory by calling get_current_dir_name before you invoke fuse_main, and then convert relative pathnames into corresponding absolute ones. Obviously, (b) is the preferred approach.
Printf
Your printf/fprintf debugging code will only work if you run with the -f switch. Otherwise, Fuse disconnects stdout and stderr.
Unimplemented functions
It is very tempting to just leave functions undefined if your filesystem doesn't need them, or if you just haven't gotten around to writing them yet. Don't. If a function isn't listed in your fuse_operations struct, Fuse will silently generate a failure when it is called, and you'll never find out that you need to write it. Instead, write every unimplemented function as a stub that prints a message to stderr and returns an error code. When you see the message, you'll know what extra functions you need to write.


segfaulting:

1       ./usr/ben/www/werc/sites/codigo.co/code/asm
du: cannot access ‘./usr/ben/www/werc/sites/codigo.co/code/Knuth’: Transport endpoint is not connected
40      ./usr/ben/www/werc/sites/codigo.co/code
du: cannot access ‘./usr/ben/www/werc/sites/codigo.co/dougfacts’: Transport endpoint is not connected
du: fts_read failed: ./usr/ben/www/werc/sites/codigo.co: Transport endpoint is not connected


opendir flags: 0x38800 /usr/ben/www/werc/sites/codigo.co/code/asm
   opendir[27893248] flags: 0x38800 /usr/ben/www/werc/sites/codigo.co/code/asm
   unique: 558, success, outsize: 32
unique: 559, opcode: READDIR (28), nodeid: 339, insize: 80, pid: 19978
readdir[27893248] from 0
Segmentation fault (core dumped)

getstat path given was /usr/ben/www/werc/sites/codigo.co/code/Unix_Shell/swiftmarks/_header.md, dir found was _header.md
getstat dname is /usr/ben/www/werc/sites/codigo.co/code/Unix_Shell bname is _header.md
getstat fd found, path is /usr/ben/www/werc/sites/codigo.co/code/Unix_Shell, ndirs is 3
getstat path given was /usr/ben/www/werc/sites/codigo.co/code/Unix_Shell/_header.md, dir found was _header.md
getstat dname is /usr/ben/www/werc/sites/codigo.co/code bname is asm
getstat fd found, path is /usr/ben/www/werc/sites/codigo.co/code, ndirs is 6
getstat path given was /usr/ben/www/werc/sites/codigo.co/code/asm, dir found was asm
fsopendir
_9pwalk done path given was /usr/ben/www/werc/sites/codigo.co/code/asm, fid's path is /usr/ben/www/werc/sites/codigo.co/code/asm
_9pdirread
_9pread on /usr/ben/www/werc/sites/codigo.co/code/asm with count 8168, offset 0, fid 1416577953
Data returned was
A with count 271
_9pread returning file offset is 271, fid for file is 1416577953
_9pdirread about to lookupdir with path /usr/ben/www/werc/sites/codigo.co/code/asm

9pfs
real    0m1.473s
user    0m0.007s
sys     0m0.027s
real    0m1.467s
user    0m0.013s
sys     0m0.027s
real    0m1.447s
user    0m0.013s
sys     0m0.023s

9pfuse
real    0m9.905s
user    0m0.010s
sys     0m0.033s
real    0m12.016s
user    0m0.000s
sys     0m0.050s
real    0m11.999s
user    0m0.003s
sys     0m0.047s

getstat dname is /usr bname is ben
getstat fd found, path is /usr, ndirs is 2
getstat path given was /usr/ben, dir found was ben
getstat dname is /usr/ben bname is yod*
getstat fd found, path is /usr/ben, ndirs is 11


seems like it is trying to read from fauth's fd right away. That
shouldn't happen yet.

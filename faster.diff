diff --git a/9p.c b/9p.c
index b590d60..7295dcb 100644
--- a/9p.c
+++ b/9p.c
@@ -3,8 +3,6 @@
 
 #include <unistd.h>
 #include <fcntl.h>
-#include <pwd.h>
-#include <grp.h>
 #include <err.h>
 
 #include <stdlib.h>
@@ -16,6 +14,7 @@
 #include "libc.h"
 #include "fcall.h"
 #include "9pfs.h"
+#include "util.h"
 
 #define	 FDEL	((void*)~0)
 
@@ -58,25 +57,20 @@ enum
 	NHASH = 1009
 };
 
-int		srvfd;
-FFid		*rootfid;
-void		*tbuf, *rbuf;
-int		fids;
-int		msize;
-FFid		*fidhash[NHASH];
-FDir		*dirhash[NHASH];
+void	*tbuf, *rbuf;
+FFid	*fidhash[NHASH];
+FDir	*dirhash[NHASH];
 
-FFid		*lookupfid(u32int, int);
-FFid		*uniqfid(void);
-FDir		*lookupdir(char*, int);
+FFid	*lookupfid(u32int, int);
+FFid	*uniqfid(void);
+FDir	*lookupdir(char*, int);
 
 void
-init9p(int sfd)
+init9p(void)
 {
 	unsigned int	seed;
 	int		rfd;
 
-	srvfd = sfd;
 	if((rfd = open("/dev/random", O_RDONLY)) == -1)
 		err(1, "Could not open /dev/random");
 	if(read(rfd, &seed, sizeof(seed)) != sizeof(seed))
@@ -110,14 +104,11 @@ do9p(Fcall *t, Fcall *r)
 	if(r->tag != t->tag)
 		errx(1, "tag mismatch");
 	if(r->type != t->type+1){
-		dprint("Type mismatch\n");
-		dprint("Expected %s got %s\n", calls2str[t->type], calls2str[r->type]);
 		goto err;
 	}
 	return 0;
 
 err:
-	dprint("9p error %s\n", r->ename);
 	r->type = Rerror;
 	return -1;
 }
@@ -127,13 +118,13 @@ _9pversion(u32int m)
 {
 	Fcall	tver, rver;
 
+	msize = m;
 	memset(&tver, 0, sizeof(tver));
 	tver.type = Tversion;
 	tver.msize = m;
 	tver.version = VERSION9P;
-	msize = m;
-	tbuf = erealloc(tbuf, msize);
-	rbuf = erealloc(rbuf, msize);
+	tbuf = erealloc(tbuf, m);
+	rbuf = erealloc(rbuf, m);
 	if(do9p(&tver, &rver) != 0)
 		errx(1, "Could not establish version");
 	if(rver.msize != m){
@@ -145,27 +136,44 @@ _9pversion(u32int m)
 }
 
 FFid*
-_9pattach(FFid* ffid, FFid *afid)
+_9pauth(u32int afid, char *uname, char *aname)
+{
+	FFid	*f;
+	Fcall	tauth, rauth;
+
+	memset(&tauth, 0, sizeof(tauth));
+	tauth.type = Tauth;
+	tauth.afid = afid;
+	tauth.uname = uname;
+	tauth.aname = aname;
+	if(do9p(&tauth, &rauth) == -1)
+		errx(1, "Could not establish authentication: %s", rauth.ename);
+	f = lookupfid(afid, PUT);
+	f->path = "AUTHFID";
+	f->fid = afid;
+	f->qid = rauth.aqid;
+	f->iounit = msize - IOHDRSZ;
+	return f;
+}
+
+FFid*
+_9pattach(u32int fid, u32int afid, char* uname, char *aname)
 {
 	FFid		*f;
 	Fcall		tattach, rattach;
-	struct passwd	*pw;
 
 	memset(&tattach, 0, sizeof(tattach));
-	if((pw = getpwuid(getuid())) == NULL)
-		errx(1, "Could not get user");
 	tattach.type = Tattach;
-	tattach.fid = ffid->fid;
-	tattach.afid = afid->fid;
-	tattach.uname = pw->pw_name;
-	tattach.msize = msize;
-	if(do9p(&tattach, &rattach) != 0)
+	tattach.fid = fid;
+	tattach.afid = afid;
+	tattach.uname = uname;
+	tattach.aname = aname;
+	if(do9p(&tattach, &rattach) == -1)
 		errx(1, "Could not attach");
-	f = lookupfid(ffid->fid, PUT);
+	f = lookupfid(fid, PUT);
 	f->path = "/";
-	f->fid = tattach.fid;
+	f->fid = fid;
 	f->qid = rattach.qid;
-	rootfid = f;
 	return f;
 }	
 
@@ -212,54 +220,56 @@ _9pwalk(const char *path)
 		free(pnew);
 		return fidclone(rootfid);
 	}
-	if((f = _9pwalkr(rootfid, pnew+1)) != NULL)
-		f->path = pnew;
-	dprint("_9pwalk done path given was %s, fid's path is %s\n", path, f->path);
+	if((f = _9pwalkr(rootfid, pnew+1)) == NULL){
+		free(pnew);
+		return NULL;
+	}
+	f->path = pnew;
 	return f;
 }
 
-void
-dir2stat(struct stat *s, Dir *d)
+Dir*
+_9pstat(FFid *f)
 {
-	struct passwd	*p;
-	struct group	*g;
-
-	s->st_dev = d->dev;
-	s->st_ino = d->qid.path;
-	s->st_mode = d->mode & 0777;
-	if(d->mode & DMDIR)
-		s->st_mode |= S_IFDIR;
-	else
-		s->st_mode |= S_IFREG;
-	s->st_nlink = 1;
-	s->st_uid = (p = getpwnam(d->uid)) == NULL ? 0 : p->pw_uid;
-	s->st_gid = (g = getgrnam(d->gid)) == NULL ? 0 : g->gr_gid;
-	s->st_size = d->length;
-	s->st_blksize = msize - IOHDRSZ;
-	s->st_blocks = d->length / (msize - IOHDRSZ) + 1;
-	s->st_atime = d->atime;
-	s->st_mtime = s->st_ctime = d->mtime;
-	s->st_rdev = 0;
-}	
-
-int
-_9pstat(FFid *f, struct stat *s)
-{
-	Dir		*d;
-	Fcall		tstat, rstat;
+	Dir	*d;
+	Fcall	tstat, rstat;
 
 	memset(&tstat, 0, sizeof(tstat));
 	tstat.type = Tstat;
 	tstat.fid = f->fid;
-	if(do9p(&tstat, &rstat) != 0)
-		return -1;
+	if(do9p(&tstat, &rstat) == -1)
+		return NULL;
 	d = emalloc(sizeof(*d) + rstat.nstat);
 	if(convM2D(rstat.stat, rstat.nstat, d, (char*)(d+1)) != rstat.nstat){
 		free(d);
+		return NULL;
+	}
+	return d;
+}
+
+int
+_9pwstat(FFid *f, Dir *d)
+{
+	Fcall	twstat, rwstat;
+	uchar	*st;
+	int	n;
+
+	n = sizeD2M(d);
+	st = emalloc(n);
+	if(convD2M(d, st, n) != n){
+		free(st);
+		return -1;
+	}
+	memset(&twstat, 0, sizeof(twstat));
+	twstat.type = Twstat;
+	twstat.fid = f->fid;
+	twstat.nstat = n;
+	twstat.stat = st;
+	if(do9p(&twstat, &rwstat) == -1){
+		free(st);
 		return -1;
 	}
-	dir2stat(s, d);
-	free(d);
+	free(st);
 	return 0;
 }
 
@@ -283,11 +293,13 @@ _9popen(FFid *f)
 }
 
 FFid*
-_9pcreate(FFid *f, char *name, int perm)
+_9pcreate(FFid *f, char *name, int perm, int isdir)
 {
 	Fcall	tcreate, rcreate;
 
 	perm &= 0777;
+	if(isdir)
+		perm |= DMDIR;
 	memset(&tcreate, 0, sizeof(tcreate));
 	tcreate.type = Tcreate;
 	tcreate.fid = f->fid;
@@ -375,24 +387,46 @@ dirpackage(uchar *buf, u32int ts, Dir **d)
 }
 
 int
+Dircmp(const void *v1, const void *v2)
+{
+	Dir	*e, *d;
+
+	e = (Dir*)v1;
+	d = (Dir*)v2;
+
+	return strcmp(e->name, d->name);
+}
+
+int
 _9pdirread(FFid *f, Dir **d)
 {
-	FDir	*fd;
-	uchar	buf[DIRMAX];
+	FDir	*fdir;
+	uchar	*buf;
 	u32int	ts, n;
+	u64int	bufsize, r;
 
-	dprint("_9pdirread\n");
 	n = f->iounit;
-	ts = _9pread(f, buf, n);
-	if(ts <= 0)
+	bufsize = DIRMAX;
+	buf = emalloc(bufsize);
+	r = 0;
+	while((ts = _9pread(f, buf+r, n)) > 0){
+		r += ts;
+		if(r > bufsize - n){
+			bufsize += DIRMAX;
+			buf = erealloc(buf, bufsize);
+		}
+	}
+	if(ts < 0){
+		free(buf);
 		return ts;
-	ts = dirpackage(buf, ts, d);
-	dprint("_9pdirread about to lookupdir with path %s\n", f->path);
-	if((fd = lookupdir(f->path, PUT)) != NULL){
-		fd->dirs = *d;
-		fd->ndirs = ts;
-		dprint("_9pdirread new FDir with ndirs %d\n", fd->ndirs);
 	}
+	ts = dirpackage(buf, r, d);
+	if((fdir = lookupdir(f->path, PUT)) != NULL){
+		fdir->dirs = *d;
+		fdir->ndirs = ts;
+		qsort(fdir->dirs, ts, sizeof(*fdir->dirs), Dircmp);
+	}
+	free(buf);
 	return ts;
 }
 
@@ -406,15 +440,11 @@ _9pread(FFid *f, void *buf, u32int n)
 	tread.fid = f->fid;
 	tread.offset = f->offset;
 	tread.count = n < f->iounit ? n : f->iounit;
-	dprint("_9pread on %s with count %u, offset %lld, fid %u\n", f->path, tread.count, tread.offset, f->fid);
 	if(do9p(&tread, &rread) == -1){
-		dprint("_9pread error returned from do9p\n");
 		return -1;
 	}
 	f->offset += rread.count;
-	dprint("Data returned was\n%s with count %d\n", rread.data, rread.count);
 	memcpy(buf, rread.data, rread.count);
-	dprint("_9pread returning file offset is %lu, fid for file is %u\n", f->offset, f->fid);
 	return rread.count;
 }
 
@@ -423,6 +453,8 @@ _9pwrite(FFid *f, void *buf, u32int n)
 {
 	Fcall	twrite, rwrite;
 
+	if(n == 0)
+		return 0;
 	memset(&twrite, 0, sizeof(twrite));
 	twrite.type = Twrite;
 	twrite.fid = f->fid;
@@ -509,8 +541,10 @@ fidclone(FFid *f)
 	twalk.fid = f->fid;
 	twalk.newfid = newf->fid;
 	twalk.nwname = 0;
-	if(do9p(&twalk, &rwalk) != 0)
+	if(do9p(&twalk, &rwalk) == -1){
+		lookupfid(f->fid, DEL);
 		return NULL;
+	}
 	if(rwalk.nwqid != 0)
 		err(1, "fidclone was not zero");
 	newf->qid = *rwalk.wqid;
@@ -552,12 +586,10 @@ lookupdir(char *path, int act)
 			free(fd->dirs);
 			fd->dirs = NULL;
 			fd->ndirs = 0;
-			dprint("lookupdir update fd with path %s\n", fd->path);
 		}else{
 			fd = emalloc(sizeof(*fd));
 			fd->path = estrdup(path);
 			*fdloc = fd;
-			dprint("lookupdir new fd with path %s\n", fd->path);
 		}
 		break;
 	case DEL:
@@ -574,32 +606,22 @@ lookupdir(char *path, int act)
 	return fd;
 }
 
-int
-getstat(struct stat *st, const char *path)
+Dir*
+isdircached(const char *path)
 {
 	FDir	*fd;
-	Dir	*d;
+	Dir	*d, e;
 	char	*dname, *bname;
 
 	dname = estrdup(path);
 	bname = strrchr(dname, '/');
 	*bname++ = '\0';
-	dprint("getstat dname is %s bname is %s\n", dname, bname);
 	if((fd = lookupdir(dname, GET)) == NULL){
 		free(dname);
-		return -1;
-	}
-	dprint("getstat fd found, path is %s, ndirs is %d\n", fd->path, fd->ndirs);
-	for(d = fd->dirs; d < fd->dirs + fd->ndirs; d++){
-		if(strcmp(d->name, bname) == 0)
-			break;
-	}
-	if(d == fd->dirs + fd->ndirs){
-		free(dname);
-		return -1;
+		return NULL;
 	}
-	dprint("getstat path given was %s, dir found was %s\n", path, d->name);
-	dir2stat(st, d);
+	e.name = bname;
+	d = bsearch(&e, fd->dirs, fd->ndirs, sizeof(*fd->dirs), Dircmp);
 	free(dname);
-	return 0;
+	return d;
 }
diff --git a/9pfs.1 b/9pfs.1
new file mode 100644
index 0000000..811dc90
--- /dev/null
+++ b/9pfs.1
@@ -0,0 +1,96 @@
+.Dd $Mdocdate: August 23 2015 $
+.Dt 9PFS 1
+.Os
+.Sh NAME
+.Nm 9pfs
+.Nd mount 9P service via FUSE
+.Sh SYNOPSIS
+.Nm 9pfs
+.Bk -words
+.Op Fl anU
+.Op Fl p Ar port
+.Op Fl u Ar user
+.Op Ar host
+.Op Ar mtpt
+.Ek
+.Sh DESCRIPTION
+.Nm 9pfs
+mounts the 9P service running at
+.Ar host
+onto
+.Ar mtpt
+using the FUSE user-level file system driver.
+.Pp
+The following options are available:
+.Bl -tag -width Ds
+.It Fl a
+Negotiate authentication using a local factotum. See
+.Sx ENVIRONMENT
+and
+.Sx EXAMPLES
+for more details.
+.It Fl n
+Do not negotiate authentication. This is the
+default.
+.It Fl U
+Specifies to connect to a UNIX-domain
+socket.
+.It Fl p Ar port
+Specifies the connection port for the 9P service.
+The default is 564.
+.It Fl u Ar user
+Specifies the username to use on authentication
+and attach to the 9P service.
+.El
+.Sh ENVIRONMENT
+.Bl -tag -width FACTOTUM
+.It Ev FACTOTUM
+Authentication requires that the 9P service
+provided by a factotum
+.Po see
+.Lk http://man.cat-v.org/9front/4/factotum
+.Pc
+is mounted at the path specified by the
+.Ev FACTOTUM
+environment variable. Plan 9 from User Space
+.Po
+aka
+.Lk https://swtch.com/plan9port/ plan9port
+.Pc
+provides a port of factotum to
+UNIX-like operating systems.
+See the
+.Sx EXAMPLES
+section below for details.
+.Sh EXAMPLES
+The following will mount a remote 9P service
+with authentication, so long as plan9port is
+installed.
+.Pp
+.Dl $ factotum -n
+.Dl $ 9pfs -U `namespace`/factotum mnt/factotum
+.Dl $ export FACTOTUM=`pwd`/mnt/factotum
+.Dl $ 9pfs -a spew.net mnt/spew
+.Dl 
+.Dl !adding key: role=client proto=p9sk1 dom=spew
+.Dl user[glenda]:
+.Dl password:
+.Dl !
+.Pp
+The utilities
+.Ar factotum
+and
+.Ar namespace
+are from Russ Cox's
+.Lk https://swtch.com/plan9port/ plan9port
+.Sh BUGS
+Files of 0 reported size are not read correctly under Linux. This
+prevents 9pfs from mounting a useful factotum under Linux. For a
+work-around, use 9pfuse to mount factotum and then proceed with
+authentication as usual.
+.Pp
+OpenBSD does not display all the files in a very large
+directory.
+.Pp
+Moving a file to a different directory is not implemented.
+To do so, copy the file and then remove it.
diff --git a/9pfs.c b/9pfs.c
index fb9896f..b73c888 100644
--- a/9pfs.c
+++ b/9pfs.c
@@ -2,9 +2,14 @@
 #include <sys/socket.h>
 #include <sys/un.h>
 
+#include <netinet/in.h>
+#include <netdb.h>
+
 #include <unistd.h>
 #include <fcntl.h>
 #include <fuse.h>
+#include <pwd.h>
+#include <grp.h>
 #include <err.h>
 #include <errno.h>
 
@@ -17,31 +22,62 @@
 #include "libc.h"
 #include "fcall.h"
 #include "9pfs.h"
+#include "auth.h"
+#include "util.h"
 
 enum
 {
 	MSIZE = 8192
 };
 
-FFid	*rootfid;
 int	debug;
 
 void	usage(void);
 
+void
+dir2stat(struct stat *s, Dir *d)
+{
+	struct passwd	*p;
+	struct group	*g;
+
+	s->st_dev = d->dev;
+	s->st_ino = d->qid.path;
+	s->st_mode = d->mode & 0777;
+	if(d->mode & DMDIR)
+		s->st_mode |= S_IFDIR;
+	else
+		s->st_mode |= S_IFREG;
+	s->st_nlink = 1;
+	s->st_uid = (p = getpwnam(d->uid)) == NULL ? 0 : p->pw_uid;
+	s->st_gid = (g = getgrnam(d->gid)) == NULL ? 0 : g->gr_gid;
+	s->st_size = d->length;
+	s->st_blksize = msize - IOHDRSZ;
+	s->st_blocks = d->length / (msize - IOHDRSZ) + 1;
+	s->st_atime = d->atime;
+	s->st_mtime = s->st_ctime = d->mtime;
+	s->st_rdev = 0;
+}	
+
 int
 fsgetattr(const char *path, struct stat *st)
 {
 	FFid	*f;
+	Dir	*d;
 
-	if(getstat(st, path) == 0)
+	if((d = isdircached(path)) != NULL){
+		dir2stat(st, d);
 		return 0;
-	if((f = _9pwalk(path)) == NULL)
+	}
+	if((f = _9pwalk(path)) == NULL){
 		return -ENOENT;
-	if(_9pstat(f, st) == -1){
+	}
+	if((d = _9pstat(f)) == NULL){
 		_9pclunk(f);
 		return -EIO;
 	}
+	dir2stat(st, d);
 	_9pclunk(f);
+	free(d);
 	return 0;
 }
 
@@ -52,27 +88,90 @@ fsrelease(const char *path, struct fuse_file_info *ffi)
 }
 
 int
+fsreleasedir(const char *path, struct fuse_file_info *ffi)
+{
+	FFid	*f;
+
+	f = (FFid*)ffi->fh;
+	if((f->qid.type & QTDIR) == 0)
+		return -ENOTDIR;
+	return _9pclunk(f);
+}
+
+int
 fstruncate(const char *path, off_t off)
 {
 	FFid	*f;
+	Dir	*d;
 
 	if((f = _9pwalk(path)) == NULL)
 		return -ENOENT;
-	f->mode = OWRITE | OTRUNC;
-	if(_9popen(f) == -1){
-		_9pclunk(f);
-		return -EIO;
+	if(off == 0){
+		f->mode = OWRITE | OTRUNC;
+		if(_9popen(f) == -1){
+			_9pclunk(f);
+			return -EIO;
+		}
+	}else{
+		if((d = _9pstat(f)) == NULL){
+			_9pclunk(f);
+			return -EIO;
+		}
+		d->length = off;
+		if(_9pwstat(f, d) == -1){
+			_9pclunk(f);
+			free(d);
+			return -EACCES;
+		}
 	}
 	_9pclunk(f);
 	return 0;
 }
+
+int
+fsrename(const char *opath, const char *npath)
+{
+	Dir	*d;
+	FFid	*f;
+	char	*dname, *bname;
+	int	n;
+
+	if((f = _9pwalk(opath)) == NULL)
+		return -ENOENT;
+	dname = estrdup(npath);
+	bname = strrchr(dname, '/');
+	n = bname - dname;
+	if(strncmp(opath, npath, n) != 0){
+		free(dname);
+		return -EACCES;
+	}
+	*bname++ = '\0';
+	if((f = _9pwalk(opath)) == NULL){
+		free(dname);
+		return -ENOENT;
+	}
+	if((d = _9pstat(f)) == NULL){
+		free(dname);
+		return -EIO;
+	}
+	d->name = bname;
+	if(_9pwstat(f, d) == -1){
+		_9pclunk(f);
+		free(dname);
+		free(d);
+		return -EACCES;
+	}
+	_9pclunk(f);
+	free(dname);
+	free(d);
+	return 0;
+}	
 	
 int
 fsopen(const char *path, struct fuse_file_info *ffi)
 {
 	FFid	*f;
 
-	dprint("fsopen on %s\n", path);
 	if((f = _9pwalk(path)) == NULL)
 		return -ENOENT;
 	f->mode = ffi->flags & O_ACCMODE;
@@ -87,27 +186,30 @@ fsopen(const char *path, struct fuse_file_info *ffi)
 }
 
 int
-fscreate(const char *path, mode_t perms, struct fuse_file_info *ffi)
+fscreate(const char *path, mode_t perm, struct fuse_file_info *ffi)
 {
 	FFid	*f;
-	char	*name, *dpath;
+	char	*dname, *bname;
 
 	if((f = _9pwalk(path)) == NULL){
-		dpath = cleanname(estrdup(path));
-		if((name = strrchr(dpath, '/')) == dpath){
-			name++;
+		dname = estrdup(path);
+		if((bname = strrchr(dname, '/')) == dname){
+			bname++;
 			f = fidclone(rootfid);
 		}else{
-			*name++ = '\0';
-			f = _9pwalk(dpath);
+			*bname++ = '\0';
+			f = _9pwalk(dname);
+		}
+		if(f == NULL){
+			free(dname);
+			return -ENOENT;
 		}
-		if(f == NULL)
-			return -EIO;
-		dprint("fscreate with perms %o and access %o\n", perms, ffi->flags&O_ACCMODE);
 		f->mode = ffi->flags & O_ACCMODE;
-		f = _9pcreate(f, name, perms);
-		if(f == NULL)
+		f = _9pcreate(f, bname, perm, 0);
+		if(f == NULL){
+			free(dname);
 			return -EIO;
+		}
 	}else{
 		if(ffi->flags | O_EXCL){
 			_9pclunk(f);
@@ -140,24 +242,15 @@ fsread(const char *path, char *buf, size_t size, off_t off,
 	struct fuse_file_info *ffi)
 {
 	FFid	*f;
-	int	r;
-	u32int	n;
+	int 	r;
 
 	f = (FFid*)ffi->fh;
-	dprint("fsread on %s with fid %u\n", path, f->fid);
 	if(f->mode & O_WRONLY)
 		return -EACCES;
 	f->offset = off;
-	n = 0;
-	while((r = _9pread(f, buf+n, size)) > 0){
-		dprint("In fsread loop r is %d: %*s\n", r, r, buf+n);
-		size -= r;
-		n += r;
-	}
-	if(r < 0)
+	if((r = _9pread(f, buf, size)) < 0)
 		return -EIO;
-	dprint("Leaving fsread, buf is: %*s\n", n, buf);
-	return n;
+	return r;
 }
 
 int
@@ -166,21 +259,14 @@ fswrite(const char *path, const char *buf, size_t size, off_t off,
 {
 	FFid	*f;
 	int	r;
-	u32int	n;
 
 	f = (FFid*)ffi->fh;
-	dprint("fswrite with mode %u\n", f->mode & O_ACCMODE);
 	if(f->mode & O_RDONLY)
 		return -EACCES;
 	f->offset = off;
-	n = 0;
-	while((r = _9pwrite(f, (char*)buf+n, size)) > 0){
-		size -= r;
-		n += r;
-	}
-	if(r < 0)
+	if((r = _9pwrite(f, (char*)buf, size)) < 0)
 		return -EIO;
-	return n;
+	return r;
 }
 
 int
@@ -188,7 +274,6 @@ fsopendir(const char *path, struct fuse_file_info *ffi)
 {
 	FFid	*f;
 
-	dprint("fsopendir\n");
 	if((f = _9pwalk(path)) == NULL)
 		return -ENOENT;
 	f->mode = ffi->flags & O_ACCMODE;
@@ -205,6 +290,54 @@ fsopendir(const char *path, struct fuse_file_info *ffi)
 }
 
 int
+fsmkdir(const char *path, mode_t perm)
+{
+	FFid	*f;
+	char	*dname, *bname;
+
+	if((f = _9pwalk(path)) != NULL){
+		_9pclunk(f);
+		return -EEXIST;
+	}
+	dname = estrdup(path);
+	if((bname = strrchr(dname, '/')) == dname){
+		bname++;
+		f = fidclone(rootfid);
+	}else{
+		*bname++ = '\0';
+		f = _9pwalk(dname);
+	}
+	if(f == NULL){
+		free(dname);
+		return -ENOENT;
+	}
+	f = _9pcreate(f, bname, perm, 1);
+	if(f == NULL){
+		free(dname);
+		return -EIO;
+	}
+	_9pclunk(f);
+	free(dname);
+	return 0;
+}
+
+int
+fsrmdir(const char *path)
+{
+	FFid	*f;
+
+	if((f = _9pwalk(path)) == NULL)
+		return -ENOENT;
+	if((f->qid.type & QTDIR) == 0){
+		_9pclunk(f);
+		return -ENOTDIR;
+	}
+	if(_9premove(f) == -1)
+		return -EIO;
+	return 0;
+}
+
+int
 fsreaddir(const char *path, void *data, fuse_fill_dir_t ffd,
 	off_t off, struct fuse_file_info *ffi)
 {
@@ -214,8 +347,8 @@ fsreaddir(const char *path, void *data, fuse_fill_dir_t ffd,
 
 	ffd(data, ".", NULL, 0);
 	ffd(data, "..", NULL, 0);
-	n = _9pdirread((FFid*)ffi->fh, &d);
-	dprint("fsreaddir returned from _9pdirread ndirs is %d\n", n);
+	if((n = _9pdirread((FFid*)ffi->fh, &d)) < 0)
+		return -EIO;
 	for(e = d; e < d + n; e++){
 		s.st_ino = e->qid.path;
 		s.st_mode = e->mode & 0777;
@@ -227,32 +360,61 @@ fsreaddir(const char *path, void *data, fuse_fill_dir_t ffd,
 struct fuse_operations fsops = {
 	.getattr =	fsgetattr,
 	.truncate =	fstruncate,
+	.rename =	fsrename,
 	.open =		fsopen,
 	.create =	fscreate,
 	.unlink =	fsunlink,
 	.read =		fsread,
 	.write =	fswrite,
 	.opendir = 	fsopendir,
+	.mkdir =	fsmkdir,
+	.rmdir =	fsrmdir,
 	.readdir = 	fsreaddir,
-	.release =	fsrelease
+	.release =	fsrelease,
+	.releasedir =	fsreleasedir
 };
 
 int
 main(int argc, char *argv[])
 {
 	FFid			rfid, afid;
-	struct sockaddr_un	p9addr;
-	char			logstr[100], *fusearg[6], **fargp;
-	int			srvfd, ch;
+	AuthInfo		*ai;
+	struct sockaddr_un	uaddr;
+	struct sockaddr		*addr;
+	struct addrinfo		*ainfo;
+	struct passwd		*pw;
+	char			logstr[100], *fusearg[6], **fargp, port[10], user[30];
+	int			ch, doauth, uflag, n, slen, e;
 
 	fargp = fusearg;
 	*fargp++ = *argv;
-	while((ch = getopt(argc, argv, ":d")) != -1){
+	doauth = 0;
+	uflag = 0;
+	strecpy(port, port+sizeof(port), "564");
+	if((pw = getpwuid(getuid())) == NULL)
+		errx(1, "Could not get user");
+	strecpy(user, user+sizeof(user), pw->pw_name);
+	while((ch = getopt(argc, argv, ":dnUap:u:")) != -1){
 		switch(ch){
 		case 'd':
 			debug = 1;
 			*fargp++ = "-d";
 			break;
+		case 'n':
+			doauth = 0;
+			break;
+		case 'U':
+			uflag = 1;
+			break;
+		case 'a':
+			doauth = 1;
+			break;
+		case 'p':
+			strecpy(port, port+sizeof(port), optarg);
+			break;
+		case 'u':
+			strecpy(user, user+sizeof(user), optarg);
+			break;
 		default:
 			usage();
 			break;
@@ -271,38 +433,43 @@ main(int argc, char *argv[])
 		setlinebuf(logfile);
 	}
 
-	memset(&p9addr, 0, sizeof(p9addr));
-	p9addr.sun_family = AF_UNIX;
-	snprintf(p9addr.sun_path, sizeof(p9addr.sun_path), "/tmp/ns.ben.:0/%s", argv[0]);
-	srvfd = socket(p9addr.sun_family, SOCK_STREAM, 0);
-	if(connect(srvfd, (struct sockaddr*)&p9addr, sizeof(p9addr)) == -1)
-		err(1, "Could not connect to %s", p9addr.sun_path);
-
-	init9p(srvfd);
-	_9pversion(MSIZE);
+	if(uflag){
+		uaddr.sun_family = AF_UNIX;
+		n = sizeof(uaddr.sun_path);
+		strecpy(uaddr.sun_path, uaddr.sun_path+n, argv[0]);
+		addr = (struct sockaddr*)&uaddr;
+		slen = sizeof(uaddr);
+	}else{
+		if((e = getaddrinfo(argv[0], port, NULL, &ainfo)) != 0)
+			errx(1, "%s", gai_strerror(e));
+		addr = ainfo->ai_addr;
+		slen = ainfo->ai_addrlen;
+	}
+	srvfd = socket(addr->sa_family, SOCK_STREAM, 0);
+	if(connect(srvfd, addr, slen) == -1)
+		err(1, "Could not connect to 9p server");
+	if(uflag == 0)
+		freeaddrinfo(ainfo);
+
+	init9p();
+	msize = _9pversion(MSIZE);
 	memset(&rfid, 0, sizeof(rfid));
 	memset(&afid, 0, sizeof(afid));
-	afid.fid = NOFID;
-	rootfid = _9pattach(&rfid, &afid);
+	if(doauth){
+		authfid = _9pauth(AUTHFID, user, NULL);
+		ai = auth_proxy(authfid, auth_getkey, "proto=p9any role=client");
+		if(ai == NULL)
+			err(1, "Could not establish authentication");
+		auth_freeAI(ai);
+	}
+	rootfid = _9pattach(ROOTFID, doauth ? AUTHFID : NOFID, user, NULL);
 	fuse_main(fargp - fusearg, fusearg, &fsops, NULL);
 	exit(0);
-}
+}	
 
 void
 usage(void)
 {
-	exit(1);
-}
-
-void
-dprint(char *fmt, ...)
-{
-	va_list	va;
-
-	if(debug == 0)
-		return;
-	va_start(va, fmt);
-	vfprintf(logfile, fmt, va);
-	va_end(va);
-	return;
+	fprintf(stderr, "usage: 9pfs [-anU] [-p port] [-u user] [host] [mtpt]\n");
+	exit(2);
 }
diff --git a/9pfs.h b/9pfs.h
index b7b08ae..c7c71ba 100644
--- a/9pfs.h
+++ b/9pfs.h
@@ -1,3 +1,9 @@
+enum
+{
+	ROOTFID,
+	AUTHFID
+};
+
 typedef struct FFid	FFid;
 typedef struct FDir	FDir;
 
@@ -18,31 +24,31 @@ struct FDir
 	char	*path;
 	Dir	*dirs;
 	int	ndirs;
+	Dir	**sdirs;
 };
 
 FILE	*logfile;
 
+FFid	*rootfid;
+FFid	*authfid;
+int	msize;
+int	srvfd;
+
+void	init9p();
 int	_9pversion(u32int);
-FFid	*_9pattach(FFid*, FFid*);
+FFid	*_9pauth(u32int, char*, char*);
+FFid	*_9pattach(u32int, u32int, char*, char*);
 FFid	*_9pwalk(const char*);
 FFid	*_9pwalkr(FFid*, char*);
-int	_9pstat(FFid*, struct stat*);
+FFid	*fidclone(FFid*);
+Dir	*_9pstat(FFid*);
+int	_9pwstat(FFid*, Dir*);
 int	_9pclunk(FFid*);
 int	_9popen(FFid*);
-FFid	*_9pcreate(FFid*, char*, int);
+FFid	*_9pcreate(FFid*, char*, int, int);
 int	_9premove(FFid*);
 int	_9pread(FFid*, void*, u32int);
 int	_9pwrite(FFid*, void*, u32int);
 int	_9pdirread(FFid*, Dir**);
 
-void	init9p(int);
-
-FFid	*fidclone(FFid*);
-int	getstat(struct stat*, const char*);
-void	*emalloc(size_t);
-void	*erealloc(void*, size_t);
-void	*ereallocarray(void*, size_t, size_t);
-void	*ecalloc(size_t, size_t);
-char	*estrdup(const char *);
-
-void	dprint(char*, ...);
+Dir	*isdircached(const char*);
diff --git a/Makefile b/Makefile
index 1169785..642e35f 100644
--- a/Makefile
+++ b/Makefile
@@ -1,25 +1,33 @@
+BIN=/usr/local/bin
+MAN=/usr/share/man/man1
 TARG=9pfs
 OBJS=9p.o\
 	util.o\
+	lib/strecpy.o\
 	lib/convD2M.o\
 	lib/convM2D.o\
 	lib/convM2S.o\
 	lib/convS2M.o\
 	lib/read9pmsg.o\
 	lib/readn.o\
-	lib/cleanname.o
+	lib/cleanname.o\
+	lib/auth_proxy.o\
+	lib/auth_rpc.o\
+	lib/auth_getkey.o
 CC=	cc
 DEBUG=	-g
 CFLAGS=	-O2 -pipe\
 		${DEBUG} -Wall\
 		-D_FILE_OFFSET_BITS=64\
-		-DFUSE_USE_VERSION=26
+		-DFUSE_USE_VERSION=26\
+		-D_GNU_SOURCE
 LDADD=	-lfuse
 
 all:	${TARG}
 
 install:	${TARG}
-	install -s ${TARG} ${HOME}/bin
+	install -s -m 555 -g bin ${TARG} ${BIN}
+	install -m 444 -g bin 9pfs.1 ${MAN}
 
 ${TARG}:	${TARG}.o ${OBJS}
 	${CC} ${LDFLAGS} -o $@ ${TARG}.o ${OBJS} ${LIB} ${LDADD}
diff --git a/auth.h b/auth.h
new file mode 100644
index 0000000..a05f1fa
--- /dev/null
+++ b/auth.h
@@ -0,0 +1,134 @@
+/*
+ * Interface for typical callers.
+ */
+
+typedef struct	AuthInfo	AuthInfo;
+typedef struct	Chalstate	Chalstate;
+typedef struct	Chapreply	Chapreply;
+typedef struct	MSchapreply	MSchapreply;
+typedef struct	UserPasswd	UserPasswd;
+typedef struct	AuthRpc		AuthRpc;
+
+enum
+{
+	MAXCHLEN=	256,		/* max challenge length	*/
+	MAXNAMELEN=	256,		/* maximum name length */
+	MD5LEN=		16,
+
+	ARok = 0,			/* rpc return values */
+	ARdone,
+	ARerror,
+	ARneedkey,
+	ARbadkey,
+	ARwritenext,
+	ARtoosmall,
+	ARtoobig,
+	ARrpcfailure,
+	ARphase,
+
+	AuthRpcMax = 4096
+};
+
+struct AuthRpc
+{
+	int afd;
+	char ibuf[AuthRpcMax+1];
+	char obuf[AuthRpcMax];
+	char *arg;
+	uint narg;
+};
+
+struct AuthInfo
+{
+	char	*cuid;		/* caller id */
+	char	*suid;		/* server id */
+	char	*cap;		/* capability (only valid on server side) */
+	int	nsecret;	/* length of secret */
+	uchar	*secret;	/* secret */
+};
+
+struct Chalstate
+{
+	char	*user;
+	char	chal[MAXCHLEN];
+	int	nchal;
+	void	*resp;
+	int	nresp;
+
+/* for implementation only */
+	int	afd;
+	AuthRpc	*rpc;			/* to factotum */
+	char	userbuf[MAXNAMELEN];	/* temp space if needed */
+	int	userinchal;		/* user was sent to obtain challenge */
+};
+
+struct	Chapreply		/* for protocol "chap" */
+{
+	uchar	id;
+	char	resp[MD5LEN];
+};
+
+struct	MSchapreply	/* for protocol "mschap" */
+{
+	char	LMresp[24];		/* Lan Manager response */
+	char	NTresp[24];		/* NT response */
+};
+
+struct	UserPasswd
+{
+	char	*user;
+	char	*passwd;
+};
+
+extern	int	newns(char*, char*);
+extern	int	addns(char*, char*);
+
+extern	int	noworld(char*);
+extern	int	amount(int, char*, int, char*);
+
+/* these two may get generalized away -rsc */
+extern	int	login(char*, char*, char*);
+extern	int	httpauth(char*, char*);
+
+typedef struct Attr Attr;
+enum {
+	AttrNameval,		/* name=val -- when matching, must have name=val */
+	AttrQuery,		/* name? -- when matching, must be present */
+	AttrDefault		/* name:=val -- when matching, if present must match INTERNAL */
+};
+struct Attr
+{
+	int type;
+	Attr *next;
+	char *name;
+	char *val;
+};
+
+typedef int AuthGetkey(char*);
+
+Attr	*_copyattr(Attr*);
+Attr	*_delattr(Attr*, char*);
+Attr	*_findattr(Attr*, char*);
+void	_freeattr(Attr*);
+Attr	*_mkattr(int, char*, char*, Attr*);
+Attr	*_parseattr(char*);
+char	*_strfindattr(Attr*, char*);
+
+extern AuthInfo*	fauth_proxy(FFid*, AuthRpc *rpc, AuthGetkey *getkey, char *params);
+extern AuthInfo*	auth_proxy(FFid*, AuthGetkey *getkey, char *fmt, ...);
+extern int		auth_getkey(char*);
+extern int		(*amount_getkey)(char*);
+extern void		auth_freeAI(AuthInfo *ai);
+extern int		auth_chuid(AuthInfo *ai, char *ns);
+extern Chalstate	*auth_challenge(char*, ...);
+extern AuthInfo*	auth_response(Chalstate*);
+extern int		auth_respond(void*, uint, char*, uint, void*, uint, AuthGetkey *getkey, char*, ...);
+extern void		auth_freechal(Chalstate*);
+extern AuthInfo*	auth_userpasswd(char *user, char *passwd);
+extern UserPasswd*	auth_getuserpasswd(AuthGetkey *getkey, char*, ...);
+extern AuthInfo*	auth_getinfo(AuthRpc *rpc);
+extern AuthRpc*		auth_allocrpc(int afd);
+extern Attr*		auth_attr(AuthRpc *rpc);
+extern void		auth_freerpc(AuthRpc *rpc);
+extern uint		auth_rpc(AuthRpc *rpc, char *verb, void *a, int n);
+extern int		auth_wep(char*, char*, ...);
diff --git a/lib/auth_getkey.c b/lib/auth_getkey.c
new file mode 100644
index 0000000..aa7104d
--- /dev/null
+++ b/lib/auth_getkey.c
@@ -0,0 +1,35 @@
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <unistd.h>
+#include <err.h>
+
+#include <stdlib.h>
+#include <stdint.h>
+#include "../libc.h"
+
+int
+auth_getkey(char *params)
+{
+	int pid, s;
+	pid_t w;
+
+	/* start /factotum to query for a key */
+	switch(pid = fork()){
+	case -1:
+		return -1;
+	case 0:
+		if(execlp("factotum", "getkey", "-g", params, nil) == -1)
+		err(1, "Could not exec factotum");
+		exit(0);
+	default:
+		for(;;){
+			w = wait(&s);
+			if(w == -1)
+				break;
+			if(w == pid){
+				return WIFEXITED(s) ? 0 : -1;
+			}
+		}
+	}
+	return 0;
+}
diff --git a/lib/auth_proxy.c b/lib/auth_proxy.c
new file mode 100644
index 0000000..fbbcb23
--- /dev/null
+++ b/lib/auth_proxy.c
@@ -0,0 +1,213 @@
+#include <sys/types.h>
+
+#include <unistd.h>
+#include <fcntl.h>
+
+#include <stdlib.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdarg.h>
+
+#include "../libc.h"
+#include "../fcall.h"
+#include "../9pfs.h"
+#include "../auth.h"
+#include "../util.h"
+
+enum {
+	ARgiveup = 100,
+};
+
+static uchar*
+gstring(uchar *p, uchar *ep, char **s)
+{
+	uint n;
+
+	if(p == nil)
+		return nil;
+	if(p+BIT16SZ > ep)
+		return nil;
+	n = GBIT16(p);
+	p += BIT16SZ;
+	if(p+n > ep)
+		return nil;
+	*s = emalloc(n+1);
+	memmove((*s), p, n);
+	(*s)[n] = '\0';
+	p += n;
+	return p;
+}
+
+static uchar*
+gcarray(uchar *p, uchar *ep, uchar **s, int *np)
+{
+	uint n;
+
+	if(p == nil)
+		return nil;
+	if(p+BIT16SZ > ep)
+		return nil;
+	n = GBIT16(p);
+	p += BIT16SZ;
+	if(p+n > ep)
+		return nil;
+	*s = emalloc(n);
+	if(*s == nil)
+		return nil;
+	memmove((*s), p, n);
+	*np = n;
+	p += n;
+	return p;
+}
+
+void
+auth_freeAI(AuthInfo *ai)
+{
+	if(ai == nil)
+		return;
+	free(ai->cuid);
+	free(ai->suid);
+	free(ai->cap);
+	free(ai->secret);
+	free(ai);
+}
+
+static uchar*
+convM2AI(uchar *p, int n, AuthInfo **aip)
+{
+	uchar *e = p+n;
+	AuthInfo *ai;
+
+	ai = emalloc(sizeof(*ai));
+	if(ai == nil)
+		return nil;
+
+	p = gstring(p, e, &ai->cuid);
+	p = gstring(p, e, &ai->suid);
+	p = gstring(p, e, &ai->cap);
+	p = gcarray(p, e, &ai->secret, &ai->nsecret);
+	if(p == nil)
+		auth_freeAI(ai);
+	else
+		*aip = ai;
+	return p;
+}
+
+AuthInfo*
+auth_getinfo(AuthRpc *rpc)
+{
+	AuthInfo *a;
+
+	if(auth_rpc(rpc, "authinfo", nil, 0) != ARok)
+		return nil;
+	if(convM2AI((uchar*)rpc->arg, rpc->narg, &a) == nil){
+		return nil;
+	}
+	return a;
+}
+
+static int
+dorpc(AuthRpc *rpc, char *verb, char *val, int len, AuthGetkey *getkey)
+{
+	int ret;
+
+	for(;;){
+		if((ret = auth_rpc(rpc, verb, val, len)) != ARneedkey && ret != ARbadkey)
+			return ret;
+		if(getkey == nil)
+			return ARgiveup;	/* don't know how */
+		if((*getkey)(rpc->arg) < 0)
+			return ARgiveup;	/* user punted */
+	}
+}
+
+/*
+ *  this just proxies what the factotum tells it to.
+ */
+AuthInfo*
+fauth_proxy(FFid *f, AuthRpc *rpc, AuthGetkey *getkey, char *params)
+{
+	char *buf;
+	int m, n, ret;
+	AuthInfo *a;
+
+	if(rpc == nil){
+		return nil;
+	}
+
+	if(dorpc(rpc, "start", params, strlen(params), getkey) != ARok){
+		return nil;
+	}
+
+	buf = emalloc(AuthRpcMax);
+	if(buf == nil)
+		return nil;
+	for(;;){
+		switch(dorpc(rpc, "read", nil, 0, getkey)){
+		case ARdone:
+			free(buf);
+			a = auth_getinfo(rpc);
+			return a;
+		case ARok:
+			if(_9pwrite(f, rpc->arg, rpc->narg) != rpc->narg){
+				goto Error;
+			}
+			break;
+		case ARphase:
+			n = 0;
+			memset(buf, 0, AuthRpcMax);
+			while((ret = dorpc(rpc, "write", buf, n, getkey)) == ARtoosmall){
+				m = atoi(rpc->arg);
+				if(m <= n || m > AuthRpcMax)
+					break;
+				m = _9pread(f, buf + n, m - n);
+				if(m <= 0)
+					goto Error;
+				n += m;
+			}
+			if(ret != ARok)
+				goto Error;
+			break;
+		default:
+			goto Error;
+		}
+	}
+Error:
+	free(buf);
+	return nil;
+}
+
+AuthInfo*
+auth_proxy(FFid *f, AuthGetkey *getkey, char *fmt, ...)
+{
+	int afd;
+	char *p, *ftm, *rpcpath;
+	va_list arg;
+	AuthInfo *ai;
+	AuthRpc *rpc;
+
+	va_start(arg, fmt);
+	vasprintf(&p, fmt, arg);
+	va_end(arg);
+
+	ai = nil;
+	ftm = getenv("FACTOTUM");
+	asprintf(&rpcpath, "%s/rpc", ftm);
+	afd = open(rpcpath, ORDWR);
+	if(afd < 0){
+		free(p);
+		free(rpcpath);
+		return nil;
+	}
+
+	rpc = auth_allocrpc(afd);
+	if(rpc){
+		ai = fauth_proxy(f, rpc, getkey, p);
+		auth_freerpc(rpc);
+	}
+	close(afd);
+	free(p);
+	free(rpcpath);
+	return ai;
+}
diff --git a/lib/auth_rpc.c b/lib/auth_rpc.c
new file mode 100644
index 0000000..5017af1
--- /dev/null
+++ b/lib/auth_rpc.c
@@ -0,0 +1,89 @@
+#include <sys/types.h>
+
+#include <unistd.h>
+
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <stdio.h>
+
+#include "../libc.h"
+#include "../fcall.h"
+#include "../9pfs.h"
+#include "../auth.h"
+#include "../util.h"
+
+static struct {
+	char *verb;
+	int val;
+} tab[] = {
+	{ "ok",		ARok },
+	{ "done",	ARdone },
+	{ "error",	ARerror },
+	{ "needkey",	ARneedkey },
+	{ "badkey",	ARbadkey },
+	{ "phase",	ARphase },
+	{ "toosmall",	ARtoosmall },
+	{ "error",	ARerror },
+};
+
+static int
+classify(char *buf, uint n, AuthRpc *rpc)
+{
+	int i, len;
+
+	for(i=0; i<nelem(tab); i++){
+		len = strlen(tab[i].verb);
+		if(n >= len && memcmp(buf, tab[i].verb, len) == 0 && (n==len || buf[len]==' ')){
+			if(n==len){
+				rpc->narg = 0;
+				rpc->arg = "";
+			}else{
+				rpc->narg = n - (len+1);
+				rpc->arg = (char*)buf+len+1;
+			}
+			return tab[i].val;
+		}
+	}
+	return ARrpcfailure;
+}
+
+AuthRpc*
+auth_allocrpc(int afd)
+{
+	AuthRpc *rpc;
+
+	rpc = emalloc(sizeof(*rpc));
+	if(rpc == nil)
+		return nil;
+	rpc->afd = afd;
+	return rpc;
+}
+
+void
+auth_freerpc(AuthRpc *rpc)
+{
+	free(rpc);
+}
+
+uint
+auth_rpc(AuthRpc *rpc, char *verb, void *a, int na)
+{
+	int l, n;
+
+	l = strlen(verb);
+	if(na+l+1 > AuthRpcMax){
+		return ARtoobig;
+	}
+
+	memmove(rpc->obuf, verb, l);
+	rpc->obuf[l] = ' ';
+	memmove(rpc->obuf+l+1, a, na);
+	if((n=write(rpc->afd, rpc->obuf, l+1+na)) != l+1+na)
+		return ARrpcfailure;
+
+	if((n=read(rpc->afd, rpc->ibuf, AuthRpcMax)) < 0)
+		return ARrpcfailure;
+	rpc->ibuf[n] = '\0';
+	return classify(rpc->ibuf, n, rpc);
+}
diff --git a/lib/read9pmsg.c b/lib/read9pmsg.c
index 480fb02..0af386d 100644
--- a/lib/read9pmsg.c
+++ b/lib/read9pmsg.c
@@ -1,6 +1,7 @@
 #include <sys/types.h>
 
 #include <stdint.h>
+
 #include "../libc.h"
 #include "../fcall.h"
 
diff --git a/lib/strecpy.c b/lib/strecpy.c
new file mode 100644
index 0000000..37afc82
--- /dev/null
+++ b/lib/strecpy.c
@@ -0,0 +1,20 @@
+#include <sys/types.h>
+
+#include <string.h>
+
+#define nil NULL
+
+char*
+strecpy(char *to, char *e, char *from)
+{
+	if(to >= e)
+		return to;
+	to = memccpy(to, from, '\0', e - to);
+	if(to == nil){
+		to = e - 1;
+		*to = '\0';
+	}else{
+		to--;
+	}
+	return to;
+}
diff --git a/libc.h b/libc.h
index 3881cac..0fa4aa9 100644
--- a/libc.h
+++ b/libc.h
@@ -1,5 +1,8 @@
 #define nil NULL
 
+#define	nelem(x)	(sizeof(x)/sizeof((x)[0]))
+
+#define	ERRMAX	256
 #define	OREAD	0	/* open for read */
 #define	OWRITE	1	/* write */
 #define	ORDWR	2	/* read and write */
@@ -89,5 +92,7 @@ struct Dir {
 	char	*ext;		/* extended info */
 } Dir;
 
+char	*strecpy(char*, char*, char*);
 long	readn(int, void*, long);
 char	*cleanname(char*);
+int	fauth(int fd, char *aname);
diff --git a/notes b/notes
index 7bdc85e..1d25532 100644
--- a/notes
+++ b/notes
@@ -356,3 +356,65 @@ sys     0m0.050s
 real    0m11.999s
 user    0m0.003s
 sys     0m0.047s
+
+getstat dname is /usr bname is ben
+getstat fd found, path is /usr, ndirs is 2
+getstat path given was /usr/ben, dir found was ben
+getstat dname is /usr/ben bname is yod*
+getstat fd found, path is /usr/ben, ndirs is 11
+
+
+seems like it is trying to read from fauth's fd right away. That
+shouldn't happen yet.
+
+Not sure if my mergesort is going to work.
+
+I have fdir->dirs = *d;
+
+Fdir->dirs is  a pointer to a dir. It is actually an array of dirs.
+
+so Fdir->dirs++ is another dir
+
+Normally you would have e.g. char *strings[NSTR];
+That's what you are sorting.
+
+So  strings is a pointer to a pointer to a char.
+char **strings;
+
+Location of first string.
+
+I think this will work...
+strings++ is the next string.
+Dir **d = &fdir->ndirs
+
+d++ is not the next dir.
+
+char **strings;
+strings[1] is a char*;
+*strings++ is a char*;
+
+Dir **d = &fdir->ndirs;
+d[0] is a Dir*;
+*d++ is not?
+
+*d is a Dir*. d holds a memory location that is the array of Dirs.
+
+d = Dir *dirs[NDIRS] essentially.
+
+set: dirs = *d;
+*d is the memory location of a dir.
+(*d)++ is the next dir. They are sequential.
+
+fdir->dirs is the first of a sequential list of pointers to Dirs?
+
+*d is the first of a sequential list of pointers to Dirs. so yes.
+
+so fdir->dirs[0] is a Dir (not a pointer). fdir->dirs[1] is a Dir (not
+a pointer).
+
+What does mergesort want? The base of the array. It would be
+nice to have an array of pointers to Dirs, but actually we have
+an array of Dirs. So more copying is going to go on.
+Not a big deal I hope.
+
+
diff --git a/readme.md b/readme.md
index 3c73e31..8fd5dd2 100644
--- a/readme.md
+++ b/readme.md
@@ -12,7 +12,8 @@ in `<fuse.h>`. This API is standardized across various OSs and so
 it works equally well on OpenBSD, FreeBSD, or Linux. It was expressly
 written for OpenBSD and developed primarily on that OS.
 
-It is also faster than 9pfuse. Below is the time it took to run du -a on my home directory on a plan 9 installation mounted by 9pfs:
+It is also faster than 9pfuse. Below is the time it took to run du
+-a on my home directory on a plan 9 installation mounted by 9pfs:
 
 ```
 $ time du -a
@@ -45,3 +46,15 @@ real    0m11.999s
 user    0m0.003s
 sys     0m0.047s
 ```
+
+Installation
+------------
+If you are using OpenBSD, then
+```
+$ make
+$ sudo make install
+```
+will perform the installation. If you are using another operating
+system of your choice, edit the the BIN and MAN variables of the
+Makefile to choose where you want to install the 9pfs binary and
+man page, respectively.
diff --git a/util.h b/util.h
new file mode 100644
index 0000000..ec94667
--- /dev/null
+++ b/util.h
@@ -0,0 +1,6 @@
+void	*emalloc(size_t);
+void	*erealloc(void*, size_t);
+void	*ereallocarray(void*, size_t, size_t);
+void	*ecalloc(size_t, size_t);
+char	*estrdup(const char *);
+void	dprint(char*, ...);
